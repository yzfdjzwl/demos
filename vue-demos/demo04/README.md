
<!-- vim-markdown-toc GFM -->
* [计算属性](#计算属性)
    * [基础例子](#基础例子)
    * [计算属性缓存vs方法](#计算属性缓存vs方法)
    * [计算属性vs侦听属性](#计算属性vs侦听属性)
    * [计算属性的setter](#计算属性的setter)
* [监听器](#监听器)

<!-- vim-markdown-toc -->

## 计算属性

模板内的表达式十分方便，但是它们的初衷是用于简单运算的。如果模板中放入了太多的逻辑会让模板过重且难以维护。比如:
```html
<div id="example">
    {{ message.split('').reverse().join('') }}
</div>
```
因此就有了计算属性。

### 基础例子
请看[这里](./index-1.html)

### 计算属性缓存vs方法

上一个例子中反转字符串也可以使用方法实现，比如:[这里](./index-2.html)， 因此使用方法和计算属性都可以达到同样的效果，但是它们之间是有区别的。

***计算属性是基于它们的依赖进行缓存的***, 也就是说依赖的值没有变过，那么多次访问计算属性的值，也不会发生变化。具体例子可以看[这里](./index-3.html)。也只有当依赖的值发生过变化后，计算属性的值才会发生变化。

### 计算属性vs侦听属性

Vue提供了一种更通用的方式来观察和响应Vue实例上的数据变动：侦听属性。当你有一些数据需要随着其他数据变动而变动时，很容易滥用 `watch`。然而，通常更好的做法是使用计算属性而不是命令式的`watch`回调。对比着可以看[这个例子](./index-4.html)。

### 计算属性的setter

计算属性默认只有getter，不过在需要时你也可以提供一个setter, 比如[这个例子](./index-5.html)

## 监听器

虽然计算属性大多数的情况下更适合，但有时候还是需要一个自定义的侦听器。这就是为什么Vue通过`watch`选项提供了一个更通用的办法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方法是更有效的。

请看[例子](./index-6.html)

除了 watch 选项之外，还可以使用命令式的 [vm.$watch API](https://cn.vuejs.org/v2/guide/class-and-style.html)
